//====================================================================
//  C言語 中級プログラミング  例題
//  単純整列算法  実行結果
//--------------------------------------------------------------------
//  SimpleSort  SimpleSortLib.c
//  Linux  GCC 4.4
//--------------------------------------------------------------------
//  富永研究室  tominaga 富永浩之
//  2017.06.22
//====================================================================


//====================================================================
//  ヘッダファイル
//====================================================================

#include <stdio.h>
#include <stdlib.h>

#include "../DataSequence/DataSequence.h"
#include "../SimpleSort/SimpleSortLib.h"


//====================================================================
//  単純整列算法  基本
//====================================================================

//--------------------------------------------------------------------
//  単純選択法
//--------------------------------------------------------------------

void SimpleSort_select(DataSequence *seq)
{
    int i, j;    // 反復変数
    int p;       // 最小要素の位置
    for ( i = 0; i < seq->size -1; i++ ) {                       // n-1回の選択パス
        p = i;                                                   // 最小候補の位置を格納
        for ( j = i+1; j < seq->size; j++ ) {                    // 整列部分の直後から配列末尾まで
            if ( ! DataSequence_order(seq, p, j) ) { p = j; }    // 最大要素の位置
        }
        DataSequence_swap(seq, i, p);                            // 最小要素の交換
    }
}

//--------------------------------------------------------------------
//  単純交換法
//--------------------------------------------------------------------

void SimpleSort_exchange(DataSequence *seq)
{
    int i, j;     // 反復変数
    int p = 0;    // 逐次交換の終了位置
    int t;        // 現在の交換位置(交換の有無のフラグとしても利用)
    for ( i = 0; i < seq->size -1; i++ ) {                // n-1回の交換パス
        t = 0;
        for ( j = seq->size -1; j > p; j-- ) {            // 配列末尾から左へ整列部分の直後まで
            if ( ! DataSequence_order(seq, j-1, j) ) {    // 隣接要素の比較
                DataSequence_swap(seq, j-1, j);           // 隣接要素の交換
                t = j;                                    // 交換があった位置
            }
        }
        if ( t == 0 ) { break; }                       // 交換がなければ打切り
        p = t;                                         // 交換があれば位置を更新
    }
}

//--------------------------------------------------------------------
//  単純挿入法
//--------------------------------------------------------------------

void SimpleSort_insert(DataSequence *seq)
{
    int i, j;    // 反復変数
    for ( i = 0; i < seq->size -1; i++ ) {                       // n-1回の挿入パス
        for ( j = i; j >= 0; j-- ) {                             // 整列部分の直後から左へ
            if ( DataSequence_order(seq, j, j+1) ) { break; }    // 挿入位置
            DataSequence_swap(seq, j, j+1);                      // 隣接要素の交換
        }
    }
}


//====================================================================
//  単純整列算法  変種
//====================================================================

//--------------------------------------------------------------------
//  シェーカーソート
//--------------------------------------------------------------------

void SimpleSort_shaker(DataSequence *seq)
{
    int i = 1;              // 左端
    int j = seq->size -1;    // 右端
    int k;                  // 反復変数
    while ( i < j ) {
        //----  左から右への交換処理
        for ( k = i; k < j; k++ ) {
            if ( ! DataSequence_order(seq, k-1, k) ) {
                DataSequence_swap(seq, k-1, k);
            }
        }
        //----  右から左への交換処理
        for ( k = j; k > i; k-- ) {
            if ( ! DataSequence_order(seq, k-1, k) ) {
                DataSequence_swap(seq, k-1, k);
            }
        }
        i++;    // 左端位置を更新
        j--;    // 右端位置を更新
    }
}

//--------------------------------------------------------------------
//  ノームソート
//--------------------------------------------------------------------

void SimpleSort_gnome(DataSequence *seq)
{
    int k = 1;                                          // 左端から開始
    while ( k < seq->size ) {                            // 右端に達するまで
        if ( DataSequence_order(seq, k-1, k) ) { k++; continue; }    // 正順なら右へ
        DataSequence_swap(seq, k-1, k);                            // 逆順なら交換して左へ
        if ( k > 1 ) { k--; } else { k++; }               // 左端なら右へ
    }
}

//--------------------------------------------------------------------
//  奇偶転置ソート
//--------------------------------------------------------------------

void SimpleSort_trans(DataSequence *seq)
{
    int k;              // 反復変数
    int flag = TRUE;    // 継続フラグ(交換の有無)
    while ( flag ) {
        flag = FALSE;    // 反復内の最初に交換無に初期化
        //----  偶奇パス(0と1、2と3などの番目の組で比較)
        for ( k = 0; k < seq->size -1; k += 2 ) {
            if ( ! DataSequence_order(seq, k, k+1) ) {
                DataSequence_swap(seq, k, k+1); flag = TRUE;
            }
        }
        //----  奇偶パス(1と2、3と4などの番目の組で比較)
        for ( k = 1; k < seq->size -1; k += 2 ) {
           if ( ! DataSequence_order(seq, k, k+1) ) {
               DataSequence_swap(seq, k, k+1); flag = TRUE;
           }
        }
        // 両方のパスで交換が起きないとき、継続フラグが偽のままで、反復を終了
    }
}

